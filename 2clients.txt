Flotilla Multi-Client Workflow Explanation (2 Clients + 1 Server)
================================================================

This document explains the flow of the Flotilla Federated Learning framework when running with 2 clients and 1 server on a single machine.

1. Infrastructure Setup (Docker)
--------------------------------
Before any Python code runs, the infrastructure must be ready.
- **MQTT Broker (Mosquitto)**: Acts as the message bus for discovery and coordination.
  - Listens on port 1883.
- **Redis**: Acts as the persistent state store for the server.
  - Listens on port 6379.

2. Server Startup (`flo_server.py`)
-----------------------------------
The server is the central coordinator (Leader).
- **Initialization**:
  - Connects to Redis to manage state (or uses in-memory if configured).
  - Starts an internal Flask server to listen for user commands (e.g., from `flo_session.py`).
- **Discovery Advertisement**:
  - Connects to the MQTT Broker.
  - Publishes a message to the topic `advert_server` saying "I am here, join me!".
  - Subscribes to `advert_client` to listen for new clients.
  - Subscribes to `heartbeat` to monitor active clients.

3. Client Startup (`flo_client.py`)
-----------------------------------
We start two separate instances of the client script. To avoid conflicts on the same machine, we use the `--client-num` argument to unique-ify resources.

### Client 1 (`--client-num 1`)
- **Identity**:
  - Generates/Loads a unique UUID (e.g., `client-uuid-1`).
  - Sets MQTT Client Name to `workstation_1`.
  - Sets Temp Directory to `temp_1/`.
- **Networking**:
  - **gRPC Ports**: Binds to ports **50053** (Sync) and **50054** (Async).
- **Handshake**:
  - Connects to MQTT Broker.
  - Subscribes to `advert_server`.
  - Sees the server's advertisement.
  - Publishes its details (UUID, IP, Port 50053, Resources) to `advert_client`.
  - Starts sending heartbeats to `heartbeat`.

### Client 2 (`--client-num 2`)
- **Identity**:
  - Generates/Loads a unique UUID (e.g., `client-uuid-2`).
  - Sets MQTT Client Name to `workstation_2`.
  - Sets Temp Directory to `temp_2/`.
- **Networking**:
  - **gRPC Ports**: Binds to ports **50055** (Sync) and **50056** (Async).
  - *Note: The offset logic is `base + (client_num - 1) * 2`.*
- **Handshake**:
  - Follows the same handshake process as Client 1, but publishes its own unique details.

4. Registration Phase
---------------------
- The **Server** receives two messages on `advert_client`.
- It registers both clients in its `client_info` database (Redis/Memory).
- It now knows:
  - Client 1 is at `localhost:50053`
  - Client 2 is at `localhost:50055`

5. Session Execution (`flo_session.py`)
---------------------------------------
The user initiates a training session.
- **Command**: `python flo_session.py config.yaml --federated_server_endpoint localhost:12345`
- **Action**: Sends a REST API request to the Server with the training configuration (Model, Rounds, Batch Size, etc.).

6. Training Loop (Round-by-Round)
---------------------------------
The Server manages the federated learning rounds.

### A. Client Selection
- The Server decides which clients participate in the current round.
- Strategy: `Random` (default) or others.
- With 2 clients available, it likely selects **both** (if `num_clients_per_round >= 2`).

### B. Connectivity Check (Echo)
- Server sends a gRPC `Echo` request to Client 1 (Port 50053) and Client 2 (Port 50055).
- Both clients respond "Ack".

### C. Model Distribution
- Server checks if clients have the latest global model.
- If not, it streams the model weights via gRPC to both clients.

### D. Training Request
- Server sends a `StartTraining` command to both clients via gRPC.
- **Parallel Execution**: This happens asynchronously. The server doesn't block waiting for Client 1 to finish before asking Client 2.

### E. Local Training (On Clients)
- **Client 1**: Loads data from its local dataset, trains the model, updates weights.
- **Client 2**: Loads data from its local dataset, trains the model, updates weights.
- Both clients send their new weights and metrics (accuracy, loss) back to the Server.

### F. Aggregation
- Server waits for responses from both clients.
- Once received, it averages the weights (e.g., FedAvg) to create a new Global Model.
- The round completes.

7. Completion
-------------
- Steps A-F repeat for the configured number of rounds (e.g., 5 rounds).
- Once finished, the Server saves the final model and logs the results.
- The Session ends.
